#include "system/gui/core.h"

vesa_info_t VESA_INFO;

// Taken from https://github.com/mkilgore/protura/blob/master/src/drivers/video/internal.h
// This is really smart and I like it.
// Each character is made up of 16 rows of pixels, each row is 8 bits wide. Making a 8x16 character.
// the 8 bit rows are condensed into hex values, which are then stored in an array.
// 0x10 becomes 0b00010000
// or |    X     | where X is a lit pixel and the empty space around the X is an unlit pixel.
uint8_t data[128][16] = {
   // Skip the first 33 rows as they are useless to the font.
	[33] =
   { 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    33 '!'
   { 0x00, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    34 '"'
   { 0x00, 0x00, 0x24, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00 }, //    35 '#'
   { 0x00, 0x10, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x7C, 0x12, 0x12, 0x92, 0x7C, 0x10, 0x10, 0x00, 0x00 }, //    36 '$'
   { 0x00, 0x00, 0x64, 0x94, 0x68, 0x08, 0x10, 0x10, 0x20, 0x2C, 0x52, 0x4C, 0x00, 0x00, 0x00, 0x00 }, //    37 '%'
   { 0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x30, 0x4A, 0x44, 0x44, 0x44, 0x3A, 0x00, 0x00, 0x00, 0x00 }, //    38 '&'
   { 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    39 '''
   { 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00 }, //    40 '('
   { 0x00, 0x00, 0x20, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 }, //    41 ')'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    42 '*'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    43 '+'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 }, //    44 ','
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    45 '-'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    46 '.'
   { 0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 }, //    47 '/'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    48 '0'
   { 0x00, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00 }, //    49 '1'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //    50 '2'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x1C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    51 '3'
   { 0x00, 0x00, 0x02, 0x06, 0x0A, 0x12, 0x22, 0x42, 0x7E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 }, //    52 '4'
   { 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    53 '5'
   { 0x00, 0x00, 0x1C, 0x20, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    54 '6'
   { 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    55 '7'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    56 '8'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00 }, //    57 '9'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    58 ':'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 }, //    59 ';'
   { 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 }, //    60 '<'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    61 '='
   { 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00 }, //    62 '>'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x04, 0x08, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00 }, //    63 '?'
   { 0x00, 0x00, 0x7C, 0x82, 0x9E, 0xA2, 0xA2, 0xA2, 0xA6, 0x9A, 0x80, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //    64 '@'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    65 'A'
   { 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 }, //    66 'B'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    67 'C'
   { 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00 }, //    68 'D'
   { 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //    69 'E'
   { 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 }, //    70 'F'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    71 'G'
   { 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    72 'H'
   { 0x00, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 }, //    73 'I'
   { 0x00, 0x00, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00 }, //    74 'J'
   { 0x00, 0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    75 'K'
   { 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //    76 'L'
   { 0x00, 0x00, 0x82, 0xC6, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00 }, //    77 'M'
   { 0x00, 0x00, 0x42, 0x42, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    78 'N'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    79 'O'
   { 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 }, //    80 'P'
   { 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4A, 0x3C, 0x02, 0x00, 0x00, 0x00 }, //    81 'Q'
   { 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    82 'R'
   { 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    83 'S'
   { 0x00, 0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    84 'T'
   { 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    85 'U'
   { 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 }, //    86 'V'
   { 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0x92, 0xAA, 0xC6, 0x82, 0x00, 0x00, 0x00, 0x00 }, //    87 'W'
   { 0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //    88 'X'
   { 0x00, 0x00, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //    89 'Y'
   { 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //    90 'Z'
   { 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00, 0x00, 0x00 }, //    91 '['
   { 0x00, 0x00, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00 }, //    92 '\'
   { 0x00, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x00, 0x00 }, //    93 ']'
   { 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    94 '^'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00 }, //    95 '_'
   { 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //    96 '`'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 }, //    97 'a'
   { 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 }, //    98 'b'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //    99 'c'
   { 0x00, 0x00, 0x02, 0x02, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 }, //   100 'd'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //   101 'e'
   { 0x00, 0x00, 0x0E, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //   102 'f'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 }, //   103 'g'
   { 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //   104 'h'
   { 0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 }, //   105 'i'
   { 0x00, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00 }, //   106 'j'
   { 0x00, 0x00, 0x40, 0x40, 0x40, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 }, //   107 'k'
   { 0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 }, //   108 'l'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00 }, //   109 'm'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //   110 'n'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 }, //   111 'o'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00 }, //   112 'p'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x02, 0x00 }, //   113 'q'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 }, //   114 'r'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00 }, //   115 's'
   { 0x00, 0x00, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0E, 0x00, 0x00, 0x00, 0x00 }, //   116 't'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 }, //   117 'u'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 }, //   118 'v'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00, 0x00, 0x00 }, //   119 'w'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 }, //   120 'x'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 }, //   121 'y'
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 }, //   122 'z'
   { 0x00, 0x00, 0x0C, 0x10, 0x10, 0x10, 0x20, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x00 }, //   123 '{'
   { 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 }, //   124 '|'
   { 0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00 }, //   125 '}'
   { 0x00, 0x62, 0x92, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //   126 '~'
};


void put_pixel(uint32_t x, uint32_t y, uint32_t color) {

   if (x >= VESA_INFO.framebuffer_width || y >= VESA_INFO.framebuffer_height)
      return;

   uint8_t r = color >> 16;
   uint8_t g = color >> 8;
   uint8_t b = color;

   uint32_t where = x * (VESA_INFO.framebuffer_bpp / 8) + y * VESA_INFO.framebuffer_pitch;

   VESA_INFO.framebuffer_pointer[where + 0] = b;
   VESA_INFO.framebuffer_pointer[where + 1] = g;
   VESA_INFO.framebuffer_pointer[where + 2] = r;

}

uint32_t put_pixel_return(uint32_t x, uint32_t y, uint32_t color) {
   // Like put_pixel except it returns the colour value of the pixel it replaced before overriding it

   if (x >= VESA_INFO.framebuffer_width || y >= VESA_INFO.framebuffer_height)
      return 0;

   uint8_t r = color >> 16;
   uint8_t g = color >> 8;
   uint8_t b = color;

   uint32_t where = x * (VESA_INFO.framebuffer_bpp / 8) + y * VESA_INFO.framebuffer_pitch;

   uint32_t old_color = (VESA_INFO.framebuffer_pointer[where + 0] << 16) | (VESA_INFO.framebuffer_pointer[where + 1] << 8) | (VESA_INFO.framebuffer_pointer[where + 2]);

   VESA_INFO.framebuffer_pointer[where + 0] = b;
   VESA_INFO.framebuffer_pointer[where + 1] = g;
   VESA_INFO.framebuffer_pointer[where + 2] = r;

   return old_color;

}

//TODO: format this code better
void draw_circle_quadrant(uint32_t cx, uint32_t cy, uint32_t x, uint32_t y, uint32_t color) {
   put_pixel(cx + x, cy + y, color);
   put_pixel(cx - x, cy + y, color);
   put_pixel(cx + x, cy - y, color);
   put_pixel(cx - x, cy - y, color);
}

void draw_rounded_rectangle(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t radius, uint32_t color) {

   int32_t error = -radius;
   int32_t x_pos = radius;
   int32_t y_pos = 0;

   while (x_pos >= y_pos) {
      draw_circle_quadrant(x + radius, y + radius, x_pos, y_pos, color);
      draw_circle_quadrant(x + width - radius - 1, y + radius, x_pos, y_pos, color);
      draw_circle_quadrant(x + width - radius - 1, y + height - radius - 1, x_pos, y_pos, color);
      draw_circle_quadrant(x + radius, y + height - radius - 1, x_pos, y_pos, color);

      draw_circle_quadrant(x + radius, y + radius, y_pos, x_pos, color);
      draw_circle_quadrant(x + width - radius - 1, y + radius, y_pos, x_pos, color);
      draw_circle_quadrant(x + width - radius - 1, y + height - radius - 1, y_pos, x_pos, color);
      draw_circle_quadrant(x + radius, y + height - radius - 1, y_pos, x_pos, color);

      error += y_pos;
      ++y_pos;
      error += y_pos;

      if (error >= 0) {
         --x_pos;
         error -= x_pos;
         error -= x_pos;
      }
   }

   // Fill the rounded corners with the specified color
   for (int32_t i = 0; i < (int32_t)radius; ++i) {
      for (int32_t j = 0; j < (int32_t)radius; ++j) {
         if (i * i + j * j < radius * radius) {
            put_pixel(x + radius - i - 1, y + radius - j - 1, color);         // Top-left corner
            put_pixel(x + width - radius + i, y + radius - j - 1, color);     // Top-right corner
            put_pixel(x + width - radius + i, y + height - radius + j, color); // Bottom-right corner
            put_pixel(x + radius - i - 1, y + height - radius + j, color);    // Bottom-left corner
         }
      }
   }

   // Fill the remaining area inside the rounded rectangle
   for (uint32_t i = x + radius; i < x + width - radius; ++i) {
      for (uint32_t j = y; j < y + height; ++j) {
         put_pixel(i, j, color);
      }
   }

   for (uint32_t i = x; i < x + width; ++i) {
      for (uint32_t j = y + radius; j < y + height - radius; ++j) {
         put_pixel(i, j, color);
      }
   }
}

void initialise_VBE(multiboot_info_t *multiboot_header) {

   VESA_INFO.framebuffer_pointer = (uint8_t*)(int32_t)(multiboot_header->framebuffer_addr);

   VESA_INFO.framebuffer_pitch = multiboot_header->framebuffer_pitch;

   VESA_INFO.framebuffer_bpp = multiboot_header->framebuffer_bpp;

   VESA_INFO.framebuffer_width = multiboot_header->framebuffer_width;
   VESA_INFO.framebuffer_height = multiboot_header->framebuffer_height;

}

// TODO: optimise this function so it doesnt call put_pixel for every pixel.
void draw_rect(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t colour) {

   for (uint32_t i = x; i < x + width; i++) {
      for (uint32_t j = y; j < y + height; j++) {
         put_pixel(i, j, colour);
      }
   }

}

uint32_t cursor_behind[100];
uint32_t old_x, old_y;

void draw_cursor(uint32_t x, uint32_t y, uint32_t colour) {
   // draw a 10x10 rect but return the colour of the pixel it replaced

   // replace the pixels behind the cursor
   uint32_t iter = 0;
   for (uint32_t i = old_x; i < old_x + 10; i++) {
      for (uint32_t j = old_y; j < old_y + 10; j++) {
         put_pixel(i, j, cursor_behind[iter]);
         iter++;
      }
   }

   old_x = x;
   old_y = y;

   iter = 0;
   for (uint32_t i = x; i < x + 10; i++) {
      for (uint32_t j = y; j < y + 10; j++) {
         cursor_behind[iter] = put_pixel_return(i, j, colour);
         iter++;
      }
   }

   // outline the cursor with a black color, still within the 10x10
   for (uint32_t i = x; i < x + 10; i++) {
      put_pixel(i, y, 0x000000);
      put_pixel(i, y + 9, 0x000000);
   }

   for (uint32_t i = y; i < y + 10; i++) {
      put_pixel(x, i, 0x000000);
      put_pixel(x + 9, i, 0x000000);
   }

}

void clear_screen(uint32_t colour) {

   draw_rect(0, 0, VESA_INFO.framebuffer_width, VESA_INFO.framebuffer_height, colour);

}

void draw_character(uint32_t x, uint32_t y, uint32_t scale, uint32_t colour, uint8_t character) {

   uint8_t font_char[16];
   memcpy(font_char, data[character], 16);

   // This reverses the font. TODO: replace this with something better or manually reverse the font.
   for (int i = 0; i < 16; i++) {

      font_char[i] = ((font_char[i] & 0xF0) >> 4) | ((font_char[i] & 0x0F) << 4);
      font_char[i] = ((font_char[i] & 0xCC) >> 2) | ((font_char[i] & 0x33) << 2);
      font_char[i] = ((font_char[i] & 0xAA) >> 1) | ((font_char[i] & 0x55) << 1);

   }

   // 8x16 font
   x = x * scale * 8;

   if (x >= VESA_INFO.framebuffer_width || y >= VESA_INFO.framebuffer_height) {
      y += 1;
      x = 0;
   }

   y = y * scale * 16;


   for (int j = 0; j < 16; j++) {

      for (int i = 0; i < 8; i++) {

         if (font_char[j] & (1 << i)) {

            draw_rect(i * scale + x, j * scale + y, scale, scale, colour);

         }

      }

   }

}

//TODO: replace this with something better...
uint16_t x, y;

void vga_print_string(char* string) {

   for (int i = 0; i < strlen(string); i++) {

      if (string[i] == '\n') {

         x = 0;
         y++;

      } else {

         draw_character(x, y, 2, 0xFFFFFF, string[i]);
         x++;

      }

   }

}